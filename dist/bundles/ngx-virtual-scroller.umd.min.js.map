{"version":3,"sources":["../../node_modules/tslib/tslib.es6.js","ng://ngx-virtual-scroller/virtual-scroller.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","__param","paramIndex","decorator","VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY","checkResizeInterval","modifyOverflowStyleOfParentScroll","resizeBypassRefreshThreshold","scrollAnimationTime","scrollDebounceTime","scrollThrottlingTime","stripedTable","VirtualScrollerComponent","element","renderer","zone","changeDetectorRef","platformId","options","this","window","executeRefreshOutsideAngularZone","_enableUnequalChildrenSizes","RTL","useMarginInsteadOfTranslate","ssrViewportWidth","ssrViewportHeight","_items","_length","compareItems","item1","item2","vsUpdate","EventEmitter","vsChange","vsStart","vsEnd","calculatedScrollbarWidth","calculatedScrollbarHeight","padding","previousViewPort","cachedPageSize","previousScrollNumberElements","isAngularUniversalSSR","isPlatformServer","scrollbarHeight","scrollbarWidth","horizontal","resetWrapGroupDimensions","prototype","pageInfo","startIndex","endIndex","scrollStartPosition","scrollEndPosition","maxScrollPosition","startIndexWithBuffer","endIndexWithBuffer","value","minMeasuredChildWidth","undefined","minMeasuredChildHeight","_bufferAmount","enableUnequalChildrenSizes","_scrollThrottlingTime","updateOnScrollFunction","_scrollDebounceTime","_this_1","onScroll","debounce","refresh_internal","throttleTrailing","_checkResizeInterval","addScrollEventHandlers","_origin","_horizontal","updateDirection","revertParentOverscroll","scrollElement","getScrollElement","oldParentScrollOverflow","style","y","x","_parentScroll","nativeElement","ngOnInit","ngOnDestroy","removeScrollEventHandlers","ngOnChanges","changes","indexLengthChanged","cachedItemsLength","listLength","firstRun","items","previousValue","ngDoCheck","viewPortItems","itemsArrayChanged","refresh","invalidateAllCachedMeasurements","wrapGroupDimensions","maxChildSizePerWrapGroup","numberOfKnownWrapGroupChildSizes","sumOfKnownWrapGroupChildWidths","sumOfKnownWrapGroupChildHeights","invalidateCachedMeasurementForItem","item","index","indexOf","invalidateCachedMeasurementAtIndex","cachedMeasurement","childWidth","childHeight","scrollInto","alignToBeginning","additionalOffset","animationMilliseconds","animationCompletedCallback","scrollToIndex","maxRetries","retryIfNeeded","dimensions","calculateDimensions","desiredStartIndex","Math","min","max","itemCount","scrollToIndex_internal","scroll","calculatePadding","wrapGroupsPerPage","_childScrollDim","scrollToPosition","scrollPosition","getElementsOffset","animationRequest","currentTween","stop","setProperty","_scrollType","tweenConfigObj","newTween","tween.Tween","to","easing","tween.Easing","Quadratic","Out","onUpdate","data","isNaN","onStop","cancelAnimationFrame","start","animate","time","update","runOutsideAngular","requestAnimationFrame","getElementSize","result","getBoundingClientRect","styles","getComputedStyle","marginTop","parseInt","marginBottom","marginLeft","marginRight","top","bottom","left","right","width","height","checkScrollElementResized","sizeChanged","boundingRect","previousScrollBoundingRect","widthChange","abs","heightChange","_invisiblePaddingProperty","_marginDir","_offsetType","_pageOffsetType","_translateDir","func","wait","throttled","apply","timeout","_arguments","_this","setTimeout","clearTimeout","itemsArrayModified","refreshCompletedCallback","maxRunTimes","oldViewPort_1","oldViewPortItems_1","oldRefreshCompletedCallback_1","scrollLengthDelta","scrollLength","oldStartItem_1","oldStartItemIndex","findIndex","itemOrderChanged","viewport","calculateViewport","startChanged","endChanged","scrollLengthChanged","paddingChanged","scrollPositionChanged","setStyle","invisiblePaddingElementRef","contentElementRef","headerElementRef","containerOffset","offset","clientHeight","changeEventArg","handleChanged","slice","emit","markForCheck","run","parentScroll","Window","document","scrollingElement","documentElement","body","disposeScrollHandler","listen","disposeResizeHandler","checkScrollElementResizedTimer","setInterval","clearInterval","containerElementRef","elementClientRect","scrollClientRect","countItemsPerWrapGroup","round","ssrChildHeight","ssrChildWidth","propertyName","children","childrenLength","firstOffset","getScrollStartPosition","windowScrollValue","oldWrapGroupDimensions","itemsPerWrapGroup","wrapGroupIndex","oldWrapGroupDimension","itemsChanged","arrayStartIndex","offsetHeight","offsetWidth","clientWidth","defaultChildWidth","defaultChildHeight","viewportWidth","viewportHeight","content","itemsPerRow","ceil","itemsPerCol","scrollOffset","maxWidthForWrapGroup","maxHeightForWrapGroup","sumOfVisibleMaxWidths","sumOfVisibleMaxHeights","child","clientRect","oldValue","maxVisibleWidthForWrapGroup","scrollOffsetToRemove","maxVisibleHeightForWrapGroup","averageChildWidth","averageChildHeight","itemsPerPage","pageCount_fractional","numberOfWrapGroups","defaultScrollLengthPerWrapGroup","numUnknownChildSizes","childSize","viewportLength","arrayStartIndexWithBuffer","startingWrapGroupIndex","floor","calculatePageInfo","scrollPercentage","totalScrolledLength","startingArrayIndex_fractional","maxStart","bufferBoundary","arrayEndIndex","endIndexWithinWrapGroup","bufferSize","bufferAmount","newPadding","newScrollLength","ElementRef","Renderer2","NgZone","ChangeDetectorRef","type","Inject","args","PLATFORM_ID","Optional","Input","Output","ViewChild","read","static","ContentChild","Component","selector","exportAs","template","host","[class.horizontal]","[class.vertical]","[class.selfScroll]","[class.rtl]","VirtualScrollerModule","NgModule","exports","declarations","imports","CommonModule","providers","provide","useFactory"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nexport function __classPrivateFieldGet(receiver, privateMap) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to get private field on non-instance\");\r\n    }\r\n    return privateMap.get(receiver);\r\n}\r\n\r\nexport function __classPrivateFieldSet(receiver, privateMap, value) {\r\n    if (!privateMap.has(receiver)) {\r\n        throw new TypeError(\"attempted to set private field on non-instance\");\r\n    }\r\n    privateMap.set(receiver, value);\r\n    return value;\r\n}\r\n","import {\n  ChangeDetectorRef,\n  Component,\n  ContentChild,\n  ElementRef,\n  EventEmitter,\n  Inject,\n  Input,\n  NgModule,\n  NgZone,\n  OnChanges,\n  OnDestroy,\n  OnInit,\n  Optional,\n  Output,\n  Renderer2,\n  ViewChild,\n} from '@angular/core';\n\nimport {PLATFORM_ID} from '@angular/core';\nimport {isPlatformServer} from '@angular/common';\n\nimport {CommonModule} from '@angular/common';\n\nimport * as tween from '@tweenjs/tween.js'\n\nexport interface VirtualScrollerDefaultOptions {\n  checkResizeInterval: number\n  modifyOverflowStyleOfParentScroll: boolean,\n  resizeBypassRefreshThreshold: number,\n  scrollAnimationTime: number;\n  scrollDebounceTime: number;\n  scrollThrottlingTime: number;\n  scrollbarHeight?: number;\n  scrollbarWidth?: number;\n  stripedTable: boolean\n}\n\nexport function VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY(): VirtualScrollerDefaultOptions {\n  return {\n    checkResizeInterval: 1000,\n    modifyOverflowStyleOfParentScroll: true,\n    resizeBypassRefreshThreshold: 5,\n    scrollAnimationTime: 750,\n    scrollDebounceTime: 0,\n    scrollThrottlingTime: 0,\n    stripedTable: false\n  };\n}\n\nexport interface WrapGroupDimensions {\n  maxChildSizePerWrapGroup: WrapGroupDimension[];\n  numberOfKnownWrapGroupChildSizes: number;\n  sumOfKnownWrapGroupChildHeights: number;\n  sumOfKnownWrapGroupChildWidths: number;\n}\n\nexport interface WrapGroupDimension {\n  childHeight: number;\n  childWidth: number;\n  items: any[];\n}\n\nexport interface IDimensions {\n  childHeight: number;\n  childWidth: number;\n  itemCount: number;\n  itemsPerPage: number;\n  itemsPerWrapGroup: number;\n  maxScrollPosition: number;\n  pageCount_fractional: number;\n  scrollLength: number;\n  viewportLength: number;\n  wrapGroupsPerPage: number;\n}\n\nexport interface IPageInfo {\n  endIndex: number;\n  endIndexWithBuffer: number;\n  maxScrollPosition: number;\n  scrollEndPosition: number;\n  scrollStartPosition: number;\n  startIndex: number;\n  startIndexWithBuffer: number;\n}\n\nexport interface IViewport extends IPageInfo {\n  padding: number;\n  scrollLength: number;\n}\n\n@Component({\n  selector: 'virtual-scroller,[virtualScroller]',\n  exportAs: 'virtualScroller',\n  template: `\n      <ng-content select=\"[outbounds]\"></ng-content>\n      <div class=\"total-padding\" #invisiblePadding></div>\n      <div class=\"scrollable-content\" #content>\n          <ng-content></ng-content>\n      </div>\n  `,\n  host: {\n    '[class.horizontal]': \"horizontal\",\n    '[class.vertical]': \"!horizontal\",\n    '[class.selfScroll]': \"!parentScroll\",\n    '[class.rtl]': \"RTL\"\n  },\n  styles: [`\n      :host {\n          position: relative;\n          display: block;\n          -webkit-overflow-scrolling: touch;\n      }\n\n      :host.horizontal.selfScroll {\n          overflow-y: visible;\n          overflow-x: auto;\n      }\n\n      :host.horizontal.selfScroll.rtl {\n          transform: scaleX(-1);\n      }\n\n      :host.vertical.selfScroll {\n          overflow-y: auto;\n          overflow-x: visible;\n      }\n\n      .scrollable-content {\n          top: 0;\n          left: 0;\n          width: 100%;\n          height: 100%;\n          max-width: 100vw;\n          max-height: 100vh;\n          position: absolute;\n      }\n\n      .scrollable-content ::ng-deep > * {\n          box-sizing: border-box;\n      }\n\n      :host.horizontal {\n          white-space: nowrap;\n      }\n\n      :host.horizontal .scrollable-content {\n          display: flex;\n      }\n\n      :host.horizontal .scrollable-content ::ng-deep > * {\n          flex-shrink: 0;\n          flex-grow: 0;\n          white-space: initial;\n      }\n\n      :host.horizontal.rtl .scrollable-content ::ng-deep > * {\n          transform: scaleX(-1);\n      }\n\n      .total-padding {\n          position: absolute;\n          top: 0;\n          left: 0;\n          height: 1px;\n          width: 1px;\n          transform-origin: 0 0;\n          opacity: 0;\n      }\n\n      :host.horizontal .total-padding {\n          height: 100%;\n      }\n  `]\n})\nexport class VirtualScrollerComponent implements OnInit, OnChanges, OnDestroy {\n  public viewPortItems: any[];\n  public window = window;\n\n  public get viewPortInfo(): IPageInfo {\n    let pageInfo: IViewport = this.previousViewPort || <any>{};\n    return {\n      startIndex: pageInfo.startIndex || 0,\n      endIndex: pageInfo.endIndex || 0,\n      scrollStartPosition: pageInfo.scrollStartPosition || 0,\n      scrollEndPosition: pageInfo.scrollEndPosition || 0,\n      maxScrollPosition: pageInfo.maxScrollPosition || 0,\n      startIndexWithBuffer: pageInfo.startIndexWithBuffer || 0,\n      endIndexWithBuffer: pageInfo.endIndexWithBuffer || 0\n    };\n  }\n\n  @Input()\n  public executeRefreshOutsideAngularZone: boolean = false;\n\n  protected _enableUnequalChildrenSizes: boolean = false;\n  @Input()\n  public get enableUnequalChildrenSizes(): boolean {\n    return this._enableUnequalChildrenSizes;\n  }\n\n  public set enableUnequalChildrenSizes(value: boolean) {\n    if (this._enableUnequalChildrenSizes === value) {\n      return;\n    }\n\n    this._enableUnequalChildrenSizes = value;\n    this.minMeasuredChildWidth = undefined;\n    this.minMeasuredChildHeight = undefined;\n  }\n\n  @Input()\n  public RTL: boolean = false;\n\n  @Input()\n  public useMarginInsteadOfTranslate: boolean = false;\n\n  @Input()\n  public modifyOverflowStyleOfParentScroll: boolean;\n\n  @Input()\n  public stripedTable: boolean;\n\n  @Input()\n  public scrollbarWidth: number;\n\n  @Input()\n  public scrollbarHeight: number;\n\n  @Input()\n  public childWidth: number;\n\n  @Input()\n  public childHeight: number;\n\n  @Input()\n  public ssrChildWidth: number;\n\n  @Input()\n  public ssrChildHeight: number;\n\n  @Input()\n  public ssrViewportWidth: number = 1920;\n\n  @Input()\n  public ssrViewportHeight: number = 1080;\n\n  protected _bufferAmount: number;\n  @Input()\n  public get bufferAmount(): number {\n    if (typeof (this._bufferAmount) === 'number' && this._bufferAmount >= 0) {\n      return this._bufferAmount;\n    } else {\n      return this.enableUnequalChildrenSizes ? 5 : 0;\n    }\n  }\n\n  public set bufferAmount(value: number) {\n    this._bufferAmount = value;\n  }\n\n  @Input()\n  public scrollAnimationTime: number;\n\n  @Input()\n  public resizeBypassRefreshThreshold: number;\n\n  protected _scrollThrottlingTime: number;\n  @Input()\n  public get scrollThrottlingTime(): number {\n    return this._scrollThrottlingTime;\n  }\n\n  public set scrollThrottlingTime(value: number) {\n    this._scrollThrottlingTime = value;\n    this.updateOnScrollFunction();\n  }\n\n  protected _scrollDebounceTime: number;\n  @Input()\n  public get scrollDebounceTime(): number {\n    return this._scrollDebounceTime;\n  }\n\n  public set scrollDebounceTime(value: number) {\n    this._scrollDebounceTime = value;\n    this.updateOnScrollFunction();\n  }\n\n  protected onScroll: () => void;\n\n  protected updateOnScrollFunction(): void {\n    if (this.scrollDebounceTime) {\n      this.onScroll = <any>this.debounce(() => {\n        this.refresh_internal(false);\n      }, this.scrollDebounceTime);\n    } else if (this.scrollThrottlingTime) {\n      this.onScroll = <any>this.throttleTrailing(() => {\n        this.refresh_internal(false);\n      }, this.scrollThrottlingTime);\n    } else {\n      this.onScroll = () => {\n        this.refresh_internal(false);\n      };\n    }\n  }\n\n  protected checkScrollElementResizedTimer: number;\n  protected _checkResizeInterval: number;\n  @Input()\n  public get checkResizeInterval(): number {\n    return this._checkResizeInterval;\n  }\n\n  public set checkResizeInterval(value: number) {\n    if (this._checkResizeInterval === value) {\n      return;\n    }\n\n    this._checkResizeInterval = value;\n    this.addScrollEventHandlers();\n  }\n\n  protected _items: any[] = [];\n  @Input()\n  public get items(): any[] {\n    return this._items;\n  }\n\n  public set items(value: any[]) {\n    if (value === this._items) {\n      return;\n    }\n\n    this._items = value || [];\n    this.refresh_internal(true);\n  }\n\n  protected _origin: any;\n  @Input()\n  public get origin(): any {\n    return this._origin;\n  }\n\n  public set origin(value: any) {\n    if (value === this._origin) {\n      return;\n    }\n\n    this._origin = value;\n    this.refresh_internal(true);\n  }\n\n  protected _length: number = 0;\n  @Input()\n  public get length(): number {\n    return this._length;\n  }\n\n  public set length(value: number) {\n    if (value === this._length) {\n      return;\n    }\n\n    this._length = value || 0;\n    this.refresh_internal(true);\n  }\n\n  @Input()\n  public compareItems: (item1: any, item2: any) => boolean = (item1: any, item2: any) => item1 === item2;\n\n  protected _horizontal: boolean;\n  @Input()\n  public get horizontal(): boolean {\n    return this._horizontal;\n  }\n\n  public set horizontal(value: boolean) {\n    this._horizontal = value;\n    this.updateDirection();\n  }\n\n  protected revertParentOverscroll(): void {\n    const scrollElement = this.getScrollElement();\n    if (scrollElement && this.oldParentScrollOverflow) {\n      scrollElement.style['overflow-y'] = this.oldParentScrollOverflow.y;\n      scrollElement.style['overflow-x'] = this.oldParentScrollOverflow.x;\n    }\n\n    this.oldParentScrollOverflow = undefined;\n  }\n\n  protected oldParentScrollOverflow: { x: string, y: string };\n  protected _parentScroll: Element | Window;\n  @Input()\n  public get parentScroll(): Element | Window {\n    return this._parentScroll;\n  }\n\n  public set parentScroll(value: Element | Window) {\n    if (this._parentScroll === value) {\n      return;\n    }\n\n    this.revertParentOverscroll();\n    this._parentScroll = value;\n    this.addScrollEventHandlers();\n\n    const scrollElement = this.getScrollElement();\n    if (this.modifyOverflowStyleOfParentScroll && scrollElement !== this.element.nativeElement) {\n      this.oldParentScrollOverflow = {x: scrollElement.style['overflow-x'], y: scrollElement.style['overflow-y']};\n      scrollElement.style['overflow-y'] = this.horizontal ? 'visible' : 'auto';\n      scrollElement.style['overflow-x'] = this.horizontal ? 'auto' : 'visible';\n    }\n  }\n\n  @Output()\n  public vsUpdate: EventEmitter<any[]> = new EventEmitter<any[]>();\n\n  @Output()\n  public vsChange: EventEmitter<IPageInfo> = new EventEmitter<IPageInfo>();\n\n  @Output()\n  public vsStart: EventEmitter<IPageInfo> = new EventEmitter<IPageInfo>();\n\n  @Output()\n  public vsEnd: EventEmitter<IPageInfo> = new EventEmitter<IPageInfo>();\n\n  @ViewChild('content', {read: ElementRef, static: true})\n  protected contentElementRef: ElementRef;\n\n  @ViewChild('invisiblePadding', {read: ElementRef, static: true})\n  protected invisiblePaddingElementRef: ElementRef;\n\n  @ContentChild('header', {read: ElementRef, static: false})\n  protected headerElementRef: ElementRef;\n\n  @ContentChild('container', {read: ElementRef, static: false})\n  protected containerElementRef: ElementRef;\n\n  public ngOnInit(): void {\n    this.addScrollEventHandlers();\n  }\n\n  public ngOnDestroy(): void {\n    this.removeScrollEventHandlers();\n    this.revertParentOverscroll();\n  }\n\n  public ngOnChanges(changes: any): void {\n    let indexLengthChanged = this.cachedItemsLength !== this.listLength;\n    this.cachedItemsLength = this.listLength;\n\n    const firstRun: boolean = !changes.items || !changes.items.previousValue || changes.items.previousValue.length === 0\n      || changes.length === 0;\n    this.refresh_internal(indexLengthChanged || firstRun);\n  }\n\n  public ngDoCheck(): void {\n    if (this.cachedItemsLength !== this.listLength) {\n      this.cachedItemsLength = this.listLength;\n      this.refresh_internal(true);\n      return;\n    }\n\n    if (this.previousViewPort && this.viewPortItems && this.viewPortItems.length > 0) {\n      let itemsArrayChanged = false;\n      for (let i = 0; i < this.viewPortItems.length; ++i) {\n        if (!this.compareItems(this.items[this.previousViewPort.startIndexWithBuffer + i], this.viewPortItems[i])) {\n          itemsArrayChanged = true;\n          break;\n        }\n      }\n      if (itemsArrayChanged) {\n        this.refresh_internal(true);\n      }\n    }\n  }\n\n  public refresh(): void {\n    this.refresh_internal(true);\n  }\n\n  public invalidateAllCachedMeasurements(): void {\n    this.wrapGroupDimensions = {\n      maxChildSizePerWrapGroup: [],\n      numberOfKnownWrapGroupChildSizes: 0,\n      sumOfKnownWrapGroupChildWidths: 0,\n      sumOfKnownWrapGroupChildHeights: 0\n    };\n\n    this.minMeasuredChildWidth = undefined;\n    this.minMeasuredChildHeight = undefined;\n\n    this.refresh_internal(false);\n  }\n\n  public invalidateCachedMeasurementForItem(item: any): void {\n    if (this.enableUnequalChildrenSizes) {\n      let index = this.items && this.items.indexOf(item);\n      if (index >= 0) {\n        this.invalidateCachedMeasurementAtIndex(index);\n      }\n    } else {\n      this.minMeasuredChildWidth = undefined;\n      this.minMeasuredChildHeight = undefined;\n    }\n\n    this.refresh_internal(false);\n  }\n\n  public invalidateCachedMeasurementAtIndex(index: number): void {\n    if (this.enableUnequalChildrenSizes) {\n      let cachedMeasurement = this.wrapGroupDimensions.maxChildSizePerWrapGroup[index];\n      if (cachedMeasurement) {\n        this.wrapGroupDimensions.maxChildSizePerWrapGroup[index] = undefined;\n        --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n        this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= cachedMeasurement.childWidth || 0;\n        this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= cachedMeasurement.childHeight || 0;\n      }\n    } else {\n      this.minMeasuredChildWidth = undefined;\n      this.minMeasuredChildHeight = undefined;\n    }\n\n    this.refresh_internal(false);\n  }\n\n  public scrollInto(item: any, alignToBeginning: boolean = true, additionalOffset: number = 0, animationMilliseconds: number = undefined, animationCompletedCallback: () => void = undefined): void {\n    let index: number = this.items ? this.items.indexOf(item) : -1;\n    if (index === -1) {\n      return;\n    }\n\n    this.scrollToIndex(index, alignToBeginning, additionalOffset, animationMilliseconds, animationCompletedCallback);\n  }\n\n  public scrollToIndex(index: number, alignToBeginning: boolean = true, additionalOffset: number = 0, animationMilliseconds: number = undefined, animationCompletedCallback: () => void = undefined): void {\n    let maxRetries: number = 5;\n\n    let retryIfNeeded = () => {\n      --maxRetries;\n      if (maxRetries <= 0) {\n        if (animationCompletedCallback) {\n          animationCompletedCallback();\n        }\n        return;\n      }\n\n      let dimensions = this.calculateDimensions();\n      let desiredStartIndex = Math.min(Math.max(index, 0), dimensions.itemCount - 1);\n      if (this.previousViewPort.startIndex === desiredStartIndex) {\n        if (animationCompletedCallback) {\n          animationCompletedCallback();\n        }\n        return;\n      }\n\n      this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, 0, retryIfNeeded);\n    };\n\n    this.scrollToIndex_internal(index, alignToBeginning, additionalOffset, animationMilliseconds, retryIfNeeded);\n  }\n\n  protected scrollToIndex_internal(index: number, alignToBeginning: boolean = true, additionalOffset: number = 0, animationMilliseconds: number = undefined, animationCompletedCallback: () => void = undefined): void {\n    animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;\n\n    let dimensions = this.calculateDimensions();\n    let scroll = this.calculatePadding(index, dimensions) + additionalOffset;\n    if (!alignToBeginning) {\n      scroll -= dimensions.wrapGroupsPerPage * dimensions[this._childScrollDim];\n    }\n\n    this.scrollToPosition(scroll, animationMilliseconds, animationCompletedCallback);\n  }\n\n  public scrollToPosition(scrollPosition: number, animationMilliseconds: number = undefined, animationCompletedCallback: () => void = undefined): void {\n    scrollPosition += this.getElementsOffset();\n\n    animationMilliseconds = animationMilliseconds === undefined ? this.scrollAnimationTime : animationMilliseconds;\n\n    let scrollElement = this.getScrollElement();\n\n    let animationRequest: number;\n\n    if (this.currentTween) {\n      this.currentTween.stop();\n      this.currentTween = undefined;\n    }\n\n    if (!animationMilliseconds) {\n      this.renderer.setProperty(scrollElement, this._scrollType, scrollPosition);\n      this.refresh_internal(false, animationCompletedCallback);\n      return;\n    }\n\n    const tweenConfigObj = {scrollPosition: scrollElement[this._scrollType]};\n\n    let newTween = new tween.Tween(tweenConfigObj)\n      .to({scrollPosition}, animationMilliseconds)\n      .easing(tween.Easing.Quadratic.Out)\n      .onUpdate((data) => {\n        if (isNaN(data.scrollPosition)) {\n          return;\n        }\n        this.renderer.setProperty(scrollElement, this._scrollType, data.scrollPosition);\n        this.refresh_internal(false);\n      })\n      .onStop(() => {\n        cancelAnimationFrame(animationRequest);\n      })\n      .start();\n\n    const animate = (time?: number) => {\n      if (!newTween[\"isPlaying\"]()) {\n        return;\n      }\n\n      newTween.update(time);\n      if (tweenConfigObj.scrollPosition === scrollPosition) {\n        this.refresh_internal(false, animationCompletedCallback);\n        return;\n      }\n\n      this.zone.runOutsideAngular(() => {\n        animationRequest = requestAnimationFrame(animate);\n      });\n    };\n\n    animate();\n    this.currentTween = newTween;\n  }\n\n  protected isAngularUniversalSSR: boolean;\n\n  constructor(\n    protected readonly element: ElementRef,\n    protected readonly renderer: Renderer2,\n    protected readonly zone: NgZone,\n    protected changeDetectorRef: ChangeDetectorRef,\n    @Inject(PLATFORM_ID) platformId: Object,\n    @Optional() @Inject('virtual-scroller-default-options')\n      options: VirtualScrollerDefaultOptions\n  ) {\n\n    this.isAngularUniversalSSR = isPlatformServer(platformId);\n\n    this.checkResizeInterval = options.checkResizeInterval;\n    this.modifyOverflowStyleOfParentScroll = options.modifyOverflowStyleOfParentScroll;\n    this.resizeBypassRefreshThreshold = options.resizeBypassRefreshThreshold;\n    this.scrollAnimationTime = options.scrollAnimationTime;\n    this.scrollDebounceTime = options.scrollDebounceTime;\n    this.scrollThrottlingTime = options.scrollThrottlingTime;\n    this.scrollbarHeight = options.scrollbarHeight;\n    this.scrollbarWidth = options.scrollbarWidth;\n    this.stripedTable = options.stripedTable;\n\n    this.horizontal = false;\n    this.resetWrapGroupDimensions();\n  }\n\n  protected get listLength(): number {\n    return this.length || (this.items && this.items.length) || 0;\n  }\n\n  protected getElementSize(element: HTMLElement): ClientRect {\n    let result = element.getBoundingClientRect();\n    let styles = getComputedStyle(element);\n    let marginTop = parseInt(styles['margin-top'], 10) || 0;\n    let marginBottom = parseInt(styles['margin-bottom'], 10) || 0;\n    let marginLeft = parseInt(styles['margin-left'], 10) || 0;\n    let marginRight = parseInt(styles['margin-right'], 10) || 0;\n\n    return {\n      top: result.top + marginTop,\n      bottom: result.bottom + marginBottom,\n      left: result.left + marginLeft,\n      right: result.right + marginRight,\n      width: result.width + marginLeft + marginRight,\n      height: result.height + marginTop + marginBottom\n    };\n  }\n\n  protected previousScrollBoundingRect: ClientRect;\n\n  protected checkScrollElementResized(): void {\n    let boundingRect = this.getElementSize(this.getScrollElement());\n\n    let sizeChanged: boolean;\n    if (!this.previousScrollBoundingRect) {\n      sizeChanged = true;\n    } else {\n      let widthChange = Math.abs(boundingRect.width - this.previousScrollBoundingRect.width);\n      let heightChange = Math.abs(boundingRect.height - this.previousScrollBoundingRect.height);\n      sizeChanged = widthChange > this.resizeBypassRefreshThreshold || heightChange > this.resizeBypassRefreshThreshold;\n    }\n\n    if (sizeChanged) {\n      this.previousScrollBoundingRect = boundingRect;\n      if (boundingRect.width > 0 && boundingRect.height > 0) {\n        this.refresh_internal(false);\n      }\n    }\n  }\n\n  protected _invisiblePaddingProperty;\n  protected _offsetType;\n  protected _scrollType;\n  protected _pageOffsetType;\n  protected _childScrollDim;\n  protected _translateDir;\n  protected _marginDir;\n\n  protected updateDirection(): void {\n    if (this.horizontal) {\n      this._childScrollDim = 'childWidth';\n      this._invisiblePaddingProperty = 'scaleX';\n      this._marginDir = 'margin-left';\n      this._offsetType = 'offsetLeft';\n      this._pageOffsetType = 'pageXOffset';\n      this._scrollType = 'scrollLeft';\n      this._translateDir = 'translateX';\n    } else {\n      this._childScrollDim = 'childHeight';\n      this._invisiblePaddingProperty = 'scaleY';\n      this._marginDir = 'margin-top';\n      this._offsetType = 'offsetTop';\n      this._pageOffsetType = 'pageYOffset';\n      this._scrollType = 'scrollTop';\n      this._translateDir = 'translateY';\n    }\n  }\n\n  protected debounce(func: Function, wait: number): Function {\n    const throttled = this.throttleTrailing(func, wait);\n    const result = function () {\n      throttled['cancel']();\n      throttled.apply(this, arguments);\n    };\n    result['cancel'] = function () {\n      throttled['cancel']();\n    };\n\n    return result;\n  }\n\n  protected throttleTrailing(func: Function, wait: number): Function {\n    let timeout = undefined;\n    let _arguments = arguments;\n    const result = function () {\n      const _this = this;\n      _arguments = arguments\n\n      if (timeout) {\n        return;\n      }\n\n      if (wait <= 0) {\n        func.apply(_this, _arguments);\n      } else {\n        timeout = setTimeout(function () {\n          timeout = undefined;\n          func.apply(_this, _arguments);\n        }, wait);\n      }\n    };\n    result['cancel'] = function () {\n      if (timeout) {\n        clearTimeout(timeout);\n        timeout = undefined;\n      }\n    };\n\n    return result;\n  }\n\n  protected calculatedScrollbarWidth: number = 0;\n  protected calculatedScrollbarHeight: number = 0;\n\n  protected padding: number = 0;\n  protected previousViewPort: IViewport = <any>{};\n  protected currentTween: tween.Tween;\n  protected cachedItemsLength: number;\n\n  protected disposeScrollHandler: () => void | undefined;\n  protected disposeResizeHandler: () => void | undefined;\n\n  protected refresh_internal(itemsArrayModified: boolean, refreshCompletedCallback: () => void = undefined, maxRunTimes: number = 2): void {\n    //note: maxRunTimes is to force it to keep recalculating if the previous iteration caused a re-render (different sliced items in viewport or scrollPosition changed).\n    //The default of 2x max will probably be accurate enough without causing too large a performance bottleneck\n    //The code would typically quit out on the 2nd iteration anyways. The main time it'd think more than 2 runs would be necessary would be for vastly different sized child items or if this is the 1st time the items array was initialized.\n    //Without maxRunTimes, If the user is actively scrolling this code would become an infinite loop until they stopped scrolling. This would be okay, except each scroll event would start an additional infinte loop. We want to short-circuit it to prevent this.\n\n    if (itemsArrayModified && this.previousViewPort && this.previousViewPort.scrollStartPosition > 0) {\n      //if items were prepended, scroll forward to keep same items visible\n      let oldViewPort = this.previousViewPort;\n      let oldViewPortItems = this.viewPortItems;\n\n      let oldRefreshCompletedCallback = refreshCompletedCallback;\n      refreshCompletedCallback = () => {\n        let scrollLengthDelta = this.previousViewPort.scrollLength - oldViewPort.scrollLength;\n        if (scrollLengthDelta > 0 && this.viewPortItems && this.items) {\n          let oldStartItem = oldViewPortItems[0];\n          let oldStartItemIndex = this.items.findIndex(x => this.compareItems(oldStartItem, x));\n          if (oldStartItemIndex > this.previousViewPort.startIndexWithBuffer) {\n            let itemOrderChanged = false;\n            for (let i = 1; i < this.viewPortItems.length; ++i) {\n              if (!this.compareItems(this.items[oldStartItemIndex + i], oldViewPortItems[i])) {\n                itemOrderChanged = true;\n                break;\n              }\n            }\n\n            if (!itemOrderChanged) {\n              this.scrollToPosition(this.previousViewPort.scrollStartPosition + scrollLengthDelta, 0, oldRefreshCompletedCallback);\n              return;\n            }\n          }\n        }\n\n        if (oldRefreshCompletedCallback) {\n          oldRefreshCompletedCallback();\n        }\n      };\n    }\n\n    this.zone.runOutsideAngular(() => {\n      requestAnimationFrame(() => {\n\n        if (itemsArrayModified) {\n          this.resetWrapGroupDimensions();\n        }\n        let viewport = this.calculateViewport();\n\n        let startChanged = itemsArrayModified || viewport.startIndex !== this.previousViewPort.startIndex;\n        let endChanged = itemsArrayModified || viewport.endIndex !== this.previousViewPort.endIndex;\n        let scrollLengthChanged = viewport.scrollLength !== this.previousViewPort.scrollLength;\n        let paddingChanged = viewport.padding !== this.previousViewPort.padding;\n        let scrollPositionChanged = viewport.scrollStartPosition !== this.previousViewPort.scrollStartPosition || viewport.scrollEndPosition !== this.previousViewPort.scrollEndPosition || viewport.maxScrollPosition !== this.previousViewPort.maxScrollPosition;\n\n        this.previousViewPort = viewport;\n\n        if (scrollLengthChanged) {\n          this.renderer.setStyle(this.invisiblePaddingElementRef.nativeElement, 'transform', `${this._invisiblePaddingProperty}(${viewport.scrollLength})`);\n          this.renderer.setStyle(this.invisiblePaddingElementRef.nativeElement, 'webkitTransform', `${this._invisiblePaddingProperty}(${viewport.scrollLength})`);\n        }\n\n        if (paddingChanged) {\n          if (this.useMarginInsteadOfTranslate) {\n            this.renderer.setStyle(this.contentElementRef.nativeElement, this._marginDir, `${viewport.padding}px`);\n          } else {\n            this.renderer.setStyle(this.contentElementRef.nativeElement, 'transform', `${this._translateDir}(${viewport.padding}px)`);\n            this.renderer.setStyle(this.contentElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${viewport.padding}px)`);\n          }\n        }\n\n        if (this.headerElementRef) {\n          let scrollPosition = this.getScrollElement()[this._scrollType];\n          let containerOffset = this.getElementsOffset();\n          let offset = Math.max(scrollPosition - viewport.padding - containerOffset + this.headerElementRef.nativeElement.clientHeight, 0);\n          this.renderer.setStyle(this.headerElementRef.nativeElement, 'transform', `${this._translateDir}(${offset}px)`);\n          this.renderer.setStyle(this.headerElementRef.nativeElement, 'webkitTransform', `${this._translateDir}(${offset}px)`);\n        }\n\n        const changeEventArg: IPageInfo = (startChanged || endChanged) ? {\n          startIndex: viewport.startIndex,\n          endIndex: viewport.endIndex,\n          scrollStartPosition: viewport.scrollStartPosition,\n          scrollEndPosition: viewport.scrollEndPosition,\n          startIndexWithBuffer: viewport.startIndexWithBuffer,\n          endIndexWithBuffer: viewport.endIndexWithBuffer,\n          maxScrollPosition: viewport.maxScrollPosition\n        } : undefined;\n\n\n        if (startChanged || endChanged || scrollPositionChanged) {\n          const handleChanged = () => {\n            if (this.items) {\n              // update the scroll list to trigger re-render of components in viewport\n              this.viewPortItems = viewport.startIndexWithBuffer >= 0 && viewport.endIndexWithBuffer >= 0 ? this.items.slice(viewport.startIndexWithBuffer, viewport.endIndexWithBuffer + 1) : [];\n              this.vsUpdate.emit(this.viewPortItems);\n            }\n\n            if (startChanged) {\n              this.vsStart.emit(changeEventArg);\n            }\n\n            if (endChanged) {\n              this.vsEnd.emit(changeEventArg);\n            }\n\n            if (startChanged || endChanged) {\n              this.changeDetectorRef.markForCheck();\n              this.vsChange.emit(changeEventArg);\n            }\n\n            if (maxRunTimes > 0) {\n              this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);\n              return;\n            }\n\n            if (refreshCompletedCallback) {\n              refreshCompletedCallback();\n            }\n          };\n\n\n          if (this.executeRefreshOutsideAngularZone) {\n            handleChanged();\n          } else {\n            this.zone.run(handleChanged);\n          }\n        } else {\n          if (maxRunTimes > 0 && (scrollLengthChanged || paddingChanged)) {\n            this.refresh_internal(false, refreshCompletedCallback, maxRunTimes - 1);\n            return;\n          }\n\n          if (refreshCompletedCallback) {\n            refreshCompletedCallback();\n          }\n        }\n      });\n    });\n  }\n\n  protected getScrollElement(): HTMLElement {\n    return this.parentScroll instanceof Window ? document.scrollingElement || document.documentElement || document.body : this.parentScroll || this.element.nativeElement;\n  }\n\n  protected addScrollEventHandlers(): void {\n    if (this.isAngularUniversalSSR) {\n      return;\n    }\n\n    let scrollElement = this.getScrollElement();\n\n    this.removeScrollEventHandlers();\n\n    this.zone.runOutsideAngular(() => {\n      if (this.parentScroll instanceof Window) {\n        this.disposeScrollHandler = this.renderer.listen('window', 'scroll', this.onScroll);\n        this.disposeResizeHandler = this.renderer.listen('window', 'resize', this.onScroll);\n      } else {\n        this.disposeScrollHandler = this.renderer.listen(scrollElement, 'scroll', this.onScroll);\n        if (this._checkResizeInterval > 0) {\n          this.checkScrollElementResizedTimer = <any>setInterval(() => {\n            this.checkScrollElementResized();\n          }, this._checkResizeInterval);\n        }\n      }\n    });\n  }\n\n  protected removeScrollEventHandlers(): void {\n    if (this.checkScrollElementResizedTimer) {\n      clearInterval(this.checkScrollElementResizedTimer);\n    }\n\n    if (this.disposeScrollHandler) {\n      this.disposeScrollHandler();\n      this.disposeScrollHandler = undefined;\n    }\n\n    if (this.disposeResizeHandler) {\n      this.disposeResizeHandler();\n      this.disposeResizeHandler = undefined;\n    }\n  }\n\n  protected getElementsOffset(): number {\n    if (this.isAngularUniversalSSR) {\n      return 0;\n    }\n\n    let offset = 0;\n\n    if (this.containerElementRef && this.containerElementRef.nativeElement) {\n      offset += this.containerElementRef.nativeElement[this._offsetType];\n    }\n\n    if (this.parentScroll) {\n      let scrollElement = this.getScrollElement();\n      let elementClientRect = this.getElementSize(this.element.nativeElement);\n      let scrollClientRect = this.getElementSize(scrollElement);\n      if (this.horizontal) {\n        offset += elementClientRect.left - scrollClientRect.left;\n      } else {\n        offset += elementClientRect.top - scrollClientRect.top;\n      }\n\n      if (!(this.parentScroll instanceof Window)) {\n        offset += scrollElement[this._scrollType];\n      }\n    }\n\n    return offset;\n  }\n\n  protected countItemsPerWrapGroup(): number {\n    if (this.isAngularUniversalSSR) {\n      return Math.round(this.horizontal ? this.ssrViewportHeight / this.ssrChildHeight : this.ssrViewportWidth / this.ssrChildWidth);\n    }\n\n    let propertyName = this.horizontal ? 'offsetLeft' : 'offsetTop';\n    let children = ((this.containerElementRef && this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement).children;\n\n    let childrenLength = children ? children.length : 0;\n    if (childrenLength === 0) {\n      return 1;\n    }\n\n    let firstOffset = children[0][propertyName];\n    let result = 1;\n    while (result < childrenLength && firstOffset === children[result][propertyName]) {\n      ++result;\n    }\n\n    return result;\n  }\n\n  protected getScrollStartPosition(): number {\n    let windowScrollValue = undefined;\n    if (this.parentScroll instanceof Window) {\n      windowScrollValue = window[this._pageOffsetType];\n    }\n\n    return windowScrollValue || this.getScrollElement()[this._scrollType] || 0;\n  }\n\n  protected minMeasuredChildWidth: number;\n  protected minMeasuredChildHeight: number;\n\n  protected wrapGroupDimensions: WrapGroupDimensions;\n\n  protected resetWrapGroupDimensions(): void {\n    const oldWrapGroupDimensions = this.wrapGroupDimensions;\n    this.invalidateAllCachedMeasurements();\n\n    if (!this.enableUnequalChildrenSizes || !oldWrapGroupDimensions || oldWrapGroupDimensions.numberOfKnownWrapGroupChildSizes === 0) {\n      return;\n    }\n\n    const itemsPerWrapGroup: number = this.countItemsPerWrapGroup();\n    for (let wrapGroupIndex = 0; wrapGroupIndex < oldWrapGroupDimensions.maxChildSizePerWrapGroup.length; ++wrapGroupIndex) {\n      const oldWrapGroupDimension: WrapGroupDimension = oldWrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];\n      if (!oldWrapGroupDimension || !oldWrapGroupDimension.items || !oldWrapGroupDimension.items.length) {\n        continue;\n      }\n\n      if (oldWrapGroupDimension.items.length !== itemsPerWrapGroup) {\n        return;\n      }\n\n      let itemsChanged = false;\n      let arrayStartIndex = itemsPerWrapGroup * wrapGroupIndex;\n      for (let i = 0; i < itemsPerWrapGroup; ++i) {\n        if (!this.compareItems(oldWrapGroupDimension.items[i], this.items[arrayStartIndex + i])) {\n          itemsChanged = true;\n          break;\n        }\n      }\n\n      if (!itemsChanged) {\n        ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n        this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += oldWrapGroupDimension.childWidth || 0;\n        this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += oldWrapGroupDimension.childHeight || 0;\n        this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = oldWrapGroupDimension;\n      }\n    }\n  }\n\n  protected calculateDimensions(): IDimensions {\n    let scrollElement = this.getScrollElement();\n\n    const maxCalculatedScrollBarSize: number = 25; // Note: Formula to auto-calculate doesn't work for ParentScroll, so we default to this if not set by consuming application\n    this.calculatedScrollbarHeight = Math.max(Math.min(scrollElement.offsetHeight - scrollElement.clientHeight, maxCalculatedScrollBarSize), this.calculatedScrollbarHeight);\n    this.calculatedScrollbarWidth = Math.max(Math.min(scrollElement.offsetWidth - scrollElement.clientWidth, maxCalculatedScrollBarSize), this.calculatedScrollbarWidth);\n\n    let viewportWidth = scrollElement.offsetWidth - (this.scrollbarWidth || this.calculatedScrollbarWidth || (this.horizontal ? 0 : maxCalculatedScrollBarSize));\n    let viewportHeight = scrollElement.offsetHeight - (this.scrollbarHeight || this.calculatedScrollbarHeight || (this.horizontal ? maxCalculatedScrollBarSize : 0));\n\n    let content = (this.containerElementRef && this.containerElementRef.nativeElement) || this.contentElementRef.nativeElement;\n\n    let itemsPerWrapGroup = this.countItemsPerWrapGroup();\n    let wrapGroupsPerPage;\n\n    let defaultChildWidth;\n    let defaultChildHeight;\n\n    if (this.isAngularUniversalSSR) {\n      viewportWidth = this.ssrViewportWidth;\n      viewportHeight = this.ssrViewportHeight;\n      defaultChildWidth = this.ssrChildWidth;\n      defaultChildHeight = this.ssrChildHeight;\n      let itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);\n      let itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);\n      wrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;\n    } else if (!this.enableUnequalChildrenSizes) {\n      if (content.children.length > 0) {\n        if (!this.childWidth || !this.childHeight) {\n          if (!this.minMeasuredChildWidth && viewportWidth > 0) {\n            this.minMeasuredChildWidth = viewportWidth;\n          }\n          if (!this.minMeasuredChildHeight && viewportHeight > 0) {\n            this.minMeasuredChildHeight = viewportHeight;\n          }\n        }\n\n        let child = content.children[0];\n        let clientRect = this.getElementSize(child);\n        this.minMeasuredChildWidth = Math.min(this.minMeasuredChildWidth, clientRect.width);\n        this.minMeasuredChildHeight = Math.min(this.minMeasuredChildHeight, clientRect.height);\n      }\n\n      defaultChildWidth = this.childWidth || this.minMeasuredChildWidth || viewportWidth;\n      defaultChildHeight = this.childHeight || this.minMeasuredChildHeight || viewportHeight;\n      let itemsPerRow = Math.max(Math.ceil(viewportWidth / defaultChildWidth), 1);\n      let itemsPerCol = Math.max(Math.ceil(viewportHeight / defaultChildHeight), 1);\n      wrapGroupsPerPage = this.horizontal ? itemsPerRow : itemsPerCol;\n    } else {\n      let scrollOffset = scrollElement[this._scrollType] - (this.previousViewPort ? this.previousViewPort.padding : 0);\n\n      let arrayStartIndex = this.previousViewPort.startIndexWithBuffer || 0;\n      let wrapGroupIndex = Math.ceil(arrayStartIndex / itemsPerWrapGroup);\n\n      let maxWidthForWrapGroup = 0;\n      let maxHeightForWrapGroup = 0;\n      let sumOfVisibleMaxWidths = 0;\n      let sumOfVisibleMaxHeights = 0;\n      wrapGroupsPerPage = 0;\n\n      for (let i = 0; i < content.children.length; ++i) {\n        ++arrayStartIndex;\n        let child = content.children[i];\n        let clientRect = this.getElementSize(child);\n\n        maxWidthForWrapGroup = Math.max(maxWidthForWrapGroup, clientRect.width);\n        maxHeightForWrapGroup = Math.max(maxHeightForWrapGroup, clientRect.height);\n\n        if (arrayStartIndex % itemsPerWrapGroup === 0) {\n          let oldValue = this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex];\n          if (oldValue) {\n            --this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n            this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths -= oldValue.childWidth || 0;\n            this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights -= oldValue.childHeight || 0;\n          }\n\n          ++this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n          const items = this.items.slice(arrayStartIndex - itemsPerWrapGroup, arrayStartIndex) || [];\n          this.wrapGroupDimensions.maxChildSizePerWrapGroup[wrapGroupIndex] = {\n            childWidth: maxWidthForWrapGroup,\n            childHeight: maxHeightForWrapGroup,\n            items: items\n          };\n          this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths += maxWidthForWrapGroup;\n          this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights += maxHeightForWrapGroup;\n\n          if (this.horizontal) {\n            let maxVisibleWidthForWrapGroup = Math.min(maxWidthForWrapGroup, Math.max(viewportWidth - sumOfVisibleMaxWidths, 0));\n            if (scrollOffset > 0) {\n              let scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleWidthForWrapGroup);\n              maxVisibleWidthForWrapGroup -= scrollOffsetToRemove;\n              scrollOffset -= scrollOffsetToRemove;\n            }\n\n            sumOfVisibleMaxWidths += maxVisibleWidthForWrapGroup;\n            if (maxVisibleWidthForWrapGroup > 0 && viewportWidth >= sumOfVisibleMaxWidths) {\n              ++wrapGroupsPerPage;\n            }\n          } else {\n            let maxVisibleHeightForWrapGroup = Math.min(maxHeightForWrapGroup, Math.max(viewportHeight - sumOfVisibleMaxHeights, 0));\n            if (scrollOffset > 0) {\n              let scrollOffsetToRemove = Math.min(scrollOffset, maxVisibleHeightForWrapGroup);\n              maxVisibleHeightForWrapGroup -= scrollOffsetToRemove;\n              scrollOffset -= scrollOffsetToRemove;\n            }\n\n            sumOfVisibleMaxHeights += maxVisibleHeightForWrapGroup;\n            if (maxVisibleHeightForWrapGroup > 0 && viewportHeight >= sumOfVisibleMaxHeights) {\n              ++wrapGroupsPerPage;\n            }\n          }\n\n          ++wrapGroupIndex;\n\n          maxWidthForWrapGroup = 0;\n          maxHeightForWrapGroup = 0;\n        }\n      }\n\n      let averageChildWidth = this.wrapGroupDimensions.sumOfKnownWrapGroupChildWidths / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n      let averageChildHeight = this.wrapGroupDimensions.sumOfKnownWrapGroupChildHeights / this.wrapGroupDimensions.numberOfKnownWrapGroupChildSizes;\n      defaultChildWidth = this.childWidth || averageChildWidth || viewportWidth;\n      defaultChildHeight = this.childHeight || averageChildHeight || viewportHeight;\n\n      if (this.horizontal) {\n        if (viewportWidth > sumOfVisibleMaxWidths) {\n          wrapGroupsPerPage += Math.ceil((viewportWidth - sumOfVisibleMaxWidths) / defaultChildWidth);\n        }\n      } else {\n        if (viewportHeight > sumOfVisibleMaxHeights) {\n          wrapGroupsPerPage += Math.ceil((viewportHeight - sumOfVisibleMaxHeights) / defaultChildHeight);\n        }\n      }\n    }\n\n    let itemCount = this.listLength;\n    let itemsPerPage = itemsPerWrapGroup * wrapGroupsPerPage;\n    let pageCount_fractional = itemCount / itemsPerPage;\n    let numberOfWrapGroups = Math.ceil(itemCount / itemsPerWrapGroup);\n\n    let scrollLength = 0;\n\n    let defaultScrollLengthPerWrapGroup = this.horizontal ? defaultChildWidth : defaultChildHeight;\n    if (this.enableUnequalChildrenSizes) {\n      let numUnknownChildSizes = 0;\n      for (let i = 0; i < numberOfWrapGroups; ++i) {\n        let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\n        if (childSize) {\n          scrollLength += childSize;\n        } else {\n          ++numUnknownChildSizes;\n        }\n      }\n\n      scrollLength += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);\n    } else {\n      scrollLength = numberOfWrapGroups * defaultScrollLengthPerWrapGroup;\n    }\n\n    if (this.headerElementRef) {\n      scrollLength += this.headerElementRef.nativeElement.clientHeight;\n    }\n\n    let viewportLength = this.horizontal ? viewportWidth : viewportHeight;\n    let maxScrollPosition = Math.max(scrollLength - viewportLength, 0);\n\n    return {\n      childHeight: defaultChildHeight,\n      childWidth: defaultChildWidth,\n      itemCount: itemCount,\n      itemsPerPage: itemsPerPage,\n      itemsPerWrapGroup: itemsPerWrapGroup,\n      maxScrollPosition: maxScrollPosition,\n      pageCount_fractional: pageCount_fractional,\n      scrollLength: scrollLength,\n      viewportLength: viewportLength,\n      wrapGroupsPerPage: wrapGroupsPerPage,\n    };\n  }\n\n  protected cachedPageSize: number = 0;\n  protected previousScrollNumberElements: number = 0;\n\n  protected calculatePadding(arrayStartIndexWithBuffer: number, dimensions: IDimensions): number {\n    if (dimensions.itemCount === 0) {\n      return 0;\n    }\n\n    let defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];\n    let startingWrapGroupIndex = Math.floor(arrayStartIndexWithBuffer / dimensions.itemsPerWrapGroup) || 0;\n\n    if (!this.enableUnequalChildrenSizes) {\n      return defaultScrollLengthPerWrapGroup * startingWrapGroupIndex;\n    }\n\n    let numUnknownChildSizes = 0;\n    let result = 0;\n    for (let i = 0; i < startingWrapGroupIndex; ++i) {\n      let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\n      if (childSize) {\n        result += childSize;\n      } else {\n        ++numUnknownChildSizes;\n      }\n    }\n    result += Math.round(numUnknownChildSizes * defaultScrollLengthPerWrapGroup);\n\n    return result;\n  }\n\n  protected calculatePageInfo(scrollPosition: number, dimensions: IDimensions): IPageInfo {\n    let scrollPercentage = 0;\n    if (this.enableUnequalChildrenSizes) {\n      const numberOfWrapGroups = Math.ceil(dimensions.itemCount / dimensions.itemsPerWrapGroup);\n      let totalScrolledLength = 0;\n      let defaultScrollLengthPerWrapGroup = dimensions[this._childScrollDim];\n      for (let i = 0; i < numberOfWrapGroups; ++i) {\n        let childSize = this.wrapGroupDimensions.maxChildSizePerWrapGroup[i] && this.wrapGroupDimensions.maxChildSizePerWrapGroup[i][this._childScrollDim];\n        if (childSize) {\n          totalScrolledLength += childSize;\n        } else {\n          totalScrolledLength += defaultScrollLengthPerWrapGroup;\n        }\n\n        if (scrollPosition < totalScrolledLength) {\n          scrollPercentage = i / numberOfWrapGroups;\n          break;\n        }\n      }\n    } else {\n      scrollPercentage = scrollPosition / dimensions.scrollLength;\n    }\n\n    let startingArrayIndex_fractional = Math.min(Math.max(scrollPercentage * dimensions.pageCount_fractional, 0), dimensions.pageCount_fractional) * dimensions.itemsPerPage;\n\n    let maxStart = dimensions.itemCount - dimensions.itemsPerPage - 1;\n    let arrayStartIndex = Math.min(Math.floor(startingArrayIndex_fractional), maxStart);\n    arrayStartIndex -= arrayStartIndex % dimensions.itemsPerWrapGroup; // round down to start of wrapGroup\n\n    if (this.stripedTable) {\n      let bufferBoundary = 2 * dimensions.itemsPerWrapGroup;\n      if (arrayStartIndex % bufferBoundary !== 0) {\n        arrayStartIndex = Math.max(arrayStartIndex - arrayStartIndex % bufferBoundary, 0);\n      }\n    }\n\n    let arrayEndIndex = Math.ceil(startingArrayIndex_fractional) + dimensions.itemsPerPage - 1;\n    let endIndexWithinWrapGroup = (arrayEndIndex + 1) % dimensions.itemsPerWrapGroup;\n    if (endIndexWithinWrapGroup > 0) {\n      arrayEndIndex += dimensions.itemsPerWrapGroup - endIndexWithinWrapGroup; // round up to end of wrapGroup\n    }\n\n    if (isNaN(arrayStartIndex)) {\n      arrayStartIndex = 0;\n    }\n    if (isNaN(arrayEndIndex)) {\n      arrayEndIndex = 0;\n    }\n\n    arrayStartIndex = Math.min(Math.max(arrayStartIndex, 0), dimensions.itemCount - 1);\n    arrayEndIndex = Math.min(Math.max(arrayEndIndex, 0), dimensions.itemCount - 1);\n\n    let bufferSize = this.bufferAmount * dimensions.itemsPerWrapGroup;\n    let startIndexWithBuffer = Math.min(Math.max(arrayStartIndex - bufferSize, 0), dimensions.itemCount - 1);\n    let endIndexWithBuffer = Math.min(Math.max(arrayEndIndex + bufferSize, 0), dimensions.itemCount - 1);\n\n    return {\n      startIndex: arrayStartIndex,\n      endIndex: arrayEndIndex,\n      startIndexWithBuffer: startIndexWithBuffer,\n      endIndexWithBuffer: endIndexWithBuffer,\n      scrollStartPosition: scrollPosition,\n      scrollEndPosition: scrollPosition + dimensions.viewportLength,\n      maxScrollPosition: dimensions.maxScrollPosition\n    };\n  }\n\n  protected calculateViewport(): IViewport {\n    let dimensions = this.calculateDimensions();\n    let offset = this.getElementsOffset();\n\n    let scrollStartPosition = this.getScrollStartPosition();\n    if (scrollStartPosition > (dimensions.scrollLength + offset) && !(this.parentScroll instanceof Window)) {\n      scrollStartPosition = dimensions.scrollLength;\n    } else {\n      scrollStartPosition -= offset;\n    }\n    scrollStartPosition = Math.max(0, scrollStartPosition);\n\n    let pageInfo = this.calculatePageInfo(scrollStartPosition, dimensions);\n    let newPadding = this.calculatePadding(pageInfo.startIndexWithBuffer, dimensions);\n    let newScrollLength = dimensions.scrollLength;\n\n    return {\n      startIndex: pageInfo.startIndex,\n      endIndex: pageInfo.endIndex,\n      startIndexWithBuffer: pageInfo.startIndexWithBuffer,\n      endIndexWithBuffer: pageInfo.endIndexWithBuffer,\n      padding: Math.round(newPadding),\n      scrollLength: Math.round(newScrollLength),\n      scrollStartPosition: pageInfo.scrollStartPosition,\n      scrollEndPosition: pageInfo.scrollEndPosition,\n      maxScrollPosition: pageInfo.maxScrollPosition\n    };\n  }\n}\n\n@NgModule({\n  exports: [VirtualScrollerComponent],\n  declarations: [VirtualScrollerComponent],\n  imports: [CommonModule],\n  providers: [\n    {\n      provide: 'virtual-scroller-default-options',\n      useFactory: VIRTUAL_SCROLLER_DEFAULT_OPTIONS_FACTORY\n    }\n  ]\n})\nexport class VirtualScrollerModule {\n}\n"]}